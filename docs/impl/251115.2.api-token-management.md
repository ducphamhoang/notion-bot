## âœ… IMPLEMENTATION COMPLETED

**Status**: All tasks completed successfully!

**Implementation Summary**:
- âœ… **Backend Token Feature Module**: Complete CRUD API for Notion API token management with repository, service, DTOs, and routes
- âœ… **NotionClientFactory**: Token resolution and client creation with fallback to environment variable
- âœ… **Task Routes Integration**: Optional `token_id` query parameter support via dependency injection
- âœ… **Frontend Token Management**: TypeScript types, API client, useTokens hook, and AuthModal "Manage Tokens" tab
- âœ… **Chat Store Integration**: selectedTokenId state with localStorage persistence, automatic token_id injection in API requests
- âœ… **Unit & Integration Tests**: Comprehensive test coverage for TokenService, token API endpoints, and task operations with tokens
- âœ… **Validation**: Frontend build (269.66 kB JS, 41.31 kB CSS) and backend type checking passed

**Key Files Created**:
- Backend: 15 new files (models, repository, services, DTOs, routes, tests, factory)
- Frontend: 3 new files (types, API client, hook)
- Modified: 4 files (task routes, main.py, chatStore, AuthModal)

**Validation Results**:
- âœ… Backend mypy type checking: PASSED (token module clean)
- âœ… Frontend ESLint: PASSED
- âœ… Frontend TypeScript build: PASSED  
- âœ… Frontend Vite production build: PASSED (gzip: 84.54 kB JS, 7.16 kB CSS)

---

I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

## CRITICAL IMPLEMENTATION NOTES âš ï¸

This plan has been **REVIEWED AND CORRECTED** for compliance with `@docs/agents/dev.md` guidelines and current codebase patterns. The following critical issues were identified and fixed:

### âœ… CORRECTED ISSUES

1. **NotionClientFactory Database Connection** (CRITICAL)
   - **Issue**: Original plan didn't show proper database connection pattern
   - **Fix**: Updated to use `DatabaseConnection()` pattern from `src/features/workspaces/routes.py:21-25`
   - **Impact**: Factory now correctly creates `TokenRepository` with database connection

2. **Task Service DI Pattern** (CRITICAL)
   - **Issue**: Original plan wanted to modify `_get_client()` method, breaking DI pattern
   - **Fix**: **NO CHANGES** to `NotionTaskService` - it already supports DI via constructor
   - **Impact**: Token selection implemented in routes layer via dependency injection function
   - **Pattern**: Routes call `NotionClientFactory.create_client(token_id)` and inject client into service

3. **Pydantic Validators** (REQUIRED)
   - **Issue**: Original plan used Pydantic v1 `@validator` syntax
   - **Fix**: Updated to Pydantic v2 `@field_validator` syntax with `@classmethod` decorators
   - **Impact**: All validators now use correct v2 syntax (codebase uses Pydantic v2.12.4)

4. **Frontend API Paths** (CLARIFIED)
   - **Issue**: Inconsistency about `/api` prefix
   - **Fix**: Confirmed NO `/api` prefix - endpoints are `/tokens`, `/tasks`, `/workspaces`
   - **Impact**: Frontend calls paths without `/api` prefix

### ðŸ“‹ ACKNOWLEDGED LIMITATIONS

The following items were considered but **NOT IMPLEMENTED** per user decision:

- âŒ **Token Encryption**: Raw tokens stored in MongoDB (no field-level encryption) - acceptable for now
- âŒ **Per-Token Rate Limiting**: Global rate limiter only - acceptable for now
- âœ… **Environment Variable Fallback**: KEPT - maintains backward compatibility

### ðŸŽ¯ KEY IMPLEMENTATION PATTERNS

1. **Dependency Injection**: All services use optional repository injection: `def __init__(self, repository: Optional[Repo] = None)`
2. **Error Handling**: Services raise domain exceptions, routes let them bubble up to global handler
3. **Database Access**: Always get connection via `DatabaseConnection()` singleton pattern
4. **Pydantic**: Use v2 syntax - `field_validator`, `json_schema_extra`, `@classmethod`
5. **Frontend Paths**: No `/api` prefix - endpoints mounted at root

### Observations

The codebase follows a well-structured pattern with clear separation of concerns:

**Backend Architecture:**
- Features organized under `src/features/` with models, repository, service, routes, and dto subdirectories
- Dependency Injection pattern enforced (per `CLAUDE.md`) with optional repository injection in services
- MongoDB accessed via Motor (AsyncIOMotorClient) through `DatabaseConnection` singleton
- Custom domain exceptions (ValidationError, NotFoundError, NotionAPIError, InternalError) handled globally
- Routers mounted in `src/main.py` with `/api` prefix implied by router definitions
- Notion client accessed via `get_notion_client()` singleton from `src/core/notion/client.py`

**Frontend Architecture:**
- React + TypeScript with Zustand for state management
- API client singleton (`apiClient`) stores API key in sessionStorage with X-API-Key header
- AuthModal has tab-based UI structure ready for extension
- Command parsing flow: user input â†’ `parseCommand` â†’ `commandToApiRequest` â†’ `apiClient` â†’ backend
- Types mirror backend DTOs for type safety

**Key Integration Points:**
1. Task routes currently don't accept `token_id` parameter - need to add as optional query param
2. `NotionTaskService` uses global `get_notion_client()` - need to switch to new factory pattern
3. Frontend `commandToApiRequest` needs to append `token_id` to all task API requests
4. Zustand store needs `selectedTokenId` state with localStorage persistence

### Approach

Implement a comprehensive API token management system following the existing codebase patterns:

**Backend (Phase 1-3):**
1. Create new `tokens` feature module with full CRUD capabilities following DI pattern
2. Implement `NotionClientFactory` to resolve tokens and create Notion clients
3. Update `NotionTaskService` and task routes to accept optional `token_id` parameter
4. Maintain backward compatibility with environment variable fallback

**Frontend (Phase 4-5):**
1. Create token API client and TypeScript types
2. Extend Zustand store with token selection state
3. Enhance AuthModal with new "Manage Tokens" tab
4. Update request flow to include `token_id` in API calls

**Testing & Documentation (Phase 6):**
1. Add unit and integration tests following existing patterns
2. Update API documentation

### Reasoning

I explored the codebase structure by listing directories, reading key files including models, repositories, services, routes, DTOs, frontend components, state management, and test configurations. I examined the dependency injection pattern from `CLAUDE.md`, understood the MongoDB connection handling, Notion client singleton pattern, and the frontend request flow from command parsing to API calls. I also reviewed the existing test fixtures to understand the mocking patterns used.

## Mermaid Diagram

sequenceDiagram
    participant User
    participant AuthModal
    participant ChatStore
    participant TokenAPI
    participant TaskAPI
    participant Backend
    participant TokenService
    participant NotionFactory
    participant NotionAPI

    Note over User,NotionAPI: Token Management Flow
    
    User->>AuthModal: Open "Manage Tokens" tab
    AuthModal->>TokenAPI: GET /tokens
    TokenAPI->>Backend: List tokens
    Backend->>TokenService: list_tokens()
    TokenService-->>Backend: TokenListResponse (masked)
    Backend-->>AuthModal: Display tokens with previews
    
    User->>AuthModal: Create new token
    AuthModal->>TokenAPI: POST /tokens {name, token, description}
    TokenAPI->>Backend: Create token
    Backend->>TokenService: create_token()
    TokenService-->>Backend: TokenResponse (masked)
    Backend-->>AuthModal: Token created
    
    User->>AuthModal: Select token (radio button)
    AuthModal->>ChatStore: setSelectedTokenId(tokenId)
    ChatStore->>ChatStore: Save to localStorage
    
    Note over User,NotionAPI: Task Creation with Token
    
    User->>ChatStore: Send command "/task create..."
    ChatStore->>ChatStore: Get selectedTokenId
    ChatStore->>TaskAPI: POST /tasks?token_id={tokenId}
    TaskAPI->>Backend: Create task with token_id
    Backend->>TokenService: Resolve token
    TokenService-->>Backend: Raw token value
    Backend->>NotionFactory: create_client(token_id)
    NotionFactory->>NotionFactory: Get token from repository
    NotionFactory-->>Backend: Notion client with token
    Backend->>NotionAPI: Create page
    NotionAPI-->>Backend: Page created
    Backend-->>ChatStore: Task created successfully
    ChatStore-->>User: Display success message
    
    Note over User,NotionAPI: Fallback to Environment Variable
    
    User->>ChatStore: Send command (no token selected)
    ChatStore->>TaskAPI: POST /tasks (no token_id)
    TaskAPI->>Backend: Create task
    Backend->>NotionFactory: create_client(token_id=None)
    NotionFactory->>NotionFactory: Use NOTION_API_KEY from env
    NotionFactory-->>Backend: Notion client with env key
    Backend->>NotionAPI: Create page
    NotionAPI-->>Backend: Page created
    Backend-->>User: Task created successfully

## Proposed File Changes

### src/features/tokens/__init__.py(NEW)

Create empty `__init__.py` file to make `tokens` a Python package, following the same pattern as other feature modules like `src/features/tasks/__init__.py` and `src/features/users/__init__.py`.

### src/features/tokens/models.py(NEW)

References: 

- src/features/workspaces/models.py
- src/features/users/models.py

Create the `NotionToken` Pydantic model for MongoDB storage:

- Use `PydanticObjectId` type from `src/features/workspaces/models.py` for the `_id` field with alias pattern
- Fields: `id` (PydanticObjectId with alias "_id"), `name` (str, 1-100 chars), `token` (str, raw Notion API token), `description` (Optional[str]), `created_at` (datetime with default_factory), `updated_at` (datetime with default_factory), `is_active` (bool, default True)
- **PYDANTIC V2 SYNTAX**: Use `field_validator` decorator (NOT `@validator`):
  ```python
  from pydantic import field_validator

  @field_validator('token')
  @classmethod
  def validate_token(cls, v: str) -> str:
      if not v.startswith('secret_'):
          raise ValueError('Token must start with "secret_"')
      return v

  @field_validator('name')
  @classmethod
  def validate_name(cls, v: str) -> str:
      v = v.strip()
      if not 1 <= len(v) <= 100:
          raise ValueError('Name must be between 1 and 100 characters')
      return v
  ```
- Include `Config` class with `populate_by_name = True` and `json_encoders` for ObjectId serialization, matching pattern from `src/features/workspaces/models.py`
- Follow the exact Pydantic model structure from `src/features/workspaces/models.py` for consistency
- **IMPORTANT**: Codebase uses Pydantic v2.12.4 - use v2 syntax for all validators

### src/features/tokens/repository.py(NEW)

References: 

- src/features/workspaces/repository.py
- src/features/users/repository.py
- src/core/database/connection.py

Create `TokenRepository` class for MongoDB CRUD operations:

- Constructor accepts optional `database` parameter (AsyncIOMotorDatabase) following pattern from `src/features/workspaces/repository.py`
- Use `@property async def collection` pattern to lazily get the `tokens` collection from database
- Implement methods:
  - `create(token_data: dict) -> NotionToken`: Insert new token, return created document
  - `get_by_id(token_id: str) -> Optional[NotionToken]`: Find token by ObjectId
  - `list_all(active_only: bool = True) -> List[NotionToken]`: List tokens with optional active filter
  - `update(token_id: str, updates: dict) -> Optional[NotionToken]`: Update token fields, set `updated_at`
  - `delete(token_id: str) -> bool`: Delete token by ID
  - `get_token_value(token_id: str) -> str`: Get raw token string for Notion API calls
- Add proper error handling with try-except blocks, raising `NotFoundError` for invalid ObjectId or missing documents
- Use `datetime.utcnow()` for timestamps
- Follow the exact repository pattern from `src/features/workspaces/repository.py` including error handling and logging

### src/features/tokens/services/__init__.py(NEW)

Create empty `__init__.py` file to make `services` a Python package.

### src/features/tokens/services/token_service.py(NEW)

References: 

- src/features/workspaces/services/workspace_service.py
- CLAUDE.md

Create `TokenService` class following the DI pattern from `CLAUDE.md`:

- Constructor: `def __init__(self, repository: Optional[TokenRepository] = None)` with `self._repository = repository or TokenRepository()` pattern from `src/features/workspaces/services/workspace_service.py`
- Implement methods:
  - `async def create_token(request: CreateTokenRequest) -> TokenResponse`: Validate token format, create in repository, return masked response
  - `async def list_tokens(active_only: bool = True) -> TokenListResponse`: Get all tokens, mask token values in response
  - `async def get_token(token_id: str) -> TokenResponse`: Get single token by ID, return masked response
  - `async def update_token(token_id: str, request: UpdateTokenRequest) -> TokenResponse`: Update token fields, return masked response
  - `async def delete_token(token_id: str) -> None`: Delete token, raise NotFoundError if not found
  - `@staticmethod def mask_token(raw_token: str) -> str`: Return masked token showing last 6 chars as "******...abc123"
- Raise domain exceptions (ValidationError, NotFoundError) - do NOT catch and convert to HTTPException per `CLAUDE.md`
- Add logging for token operations (creation, updates, deletion) but never log raw token values
- Follow the service pattern from `src/features/workspaces/services/workspace_service.py`

### src/features/tokens/dto/__init__.py(NEW)

Create empty `__init__.py` file to make `dto` a Python package.

### src/features/tokens/dto/create_token_request.py(NEW)

References: 

- src/features/workspaces/dto/create_workspace_request.py
- src/features/tasks/dto/create_task_request.py

Create `CreateTokenRequest` Pydantic model:

- Fields: `name` (str, required, 1-100 chars), `token` (str, required), `description` (Optional[str])
- **PYDANTIC V2 SYNTAX**: Use `field_validator` decorator:
  ```python
  from pydantic import BaseModel, Field, field_validator

  @field_validator('token')
  @classmethod
  def validate_token(cls, v: str) -> str:
      if not v.startswith('secret_'):
          raise ValueError('Token must start with "secret_"')
      return v

  @field_validator('name')
  @classmethod
  def validate_name(cls, v: str) -> str:
      v = v.strip()
      if not 1 <= len(v) <= 100:
          raise ValueError('Name must be between 1 and 100 characters')
      return v
  ```
- Include `Config` class with `extra = "forbid"` and `json_schema_extra` example (note: v2 uses `json_schema_extra` not `schema_extra`)
- Follow the DTO pattern from `src/features/workspaces/dto/create_workspace_request.py` and `src/features/tasks/dto/create_task_request.py`

### src/features/tokens/dto/update_token_request.py(NEW)

References: 

- src/features/tasks/dto/update_task_request.py

Create `UpdateTokenRequest` Pydantic model:

- All fields optional: `name` (Optional[str]), `description` (Optional[str]), `is_active` (Optional[bool])
- **PYDANTIC V2 SYNTAX**: Use `field_validator` with `mode='before'` for optional fields:
  ```python
  from pydantic import field_validator

  @field_validator('name')
  @classmethod
  def validate_name(cls, v: Optional[str]) -> Optional[str]:
      if v is not None:
          v = v.strip()
          if not 1 <= len(v) <= 100:
              raise ValueError('Name must be between 1 and 100 characters')
      return v
  ```
- Include `Config` class with `extra = "forbid"` and `json_schema_extra` example
- Follow the DTO pattern from `src/features/tasks/dto/update_task_request.py`

### src/features/tokens/dto/token_response.py(NEW)

References: 

- src/features/workspaces/dto/workspace_response.py

Create `TokenResponse` Pydantic model for API responses:

- Fields: `id` (str), `name` (str), `token_preview` (str, masked token), `description` (Optional[str]), `created_at` (datetime), `updated_at` (datetime), `is_active` (bool)
- Add `@classmethod from_token(cls, token: NotionToken, mask_token_fn) -> TokenResponse` factory method to convert model to response DTO
- Include `Config` class with `from_attributes = True`, `json_encoders` for datetime, and `schema_extra` example
- Follow the response DTO pattern from `src/features/workspaces/dto/workspace_response.py`
- IMPORTANT: Never include the raw token value in this response model

### src/features/tokens/dto/token_list_response.py(NEW)

References: 

- src/features/workspaces/dto/workspace_response.py

Create `TokenListResponse` Pydantic model:

- Fields: `tokens` (List[TokenResponse]), `total` (int)
- Include `Config` class with `schema_extra` example
- Follow the list response pattern from `src/features/workspaces/dto/workspace_response.py` (WorkspaceListResponse)

### src/features/tokens/routes.py(NEW)

References: 

- src/features/workspaces/routes.py
- src/features/tasks/routes.py(MODIFY)
- CLAUDE.md

Create FastAPI router for token CRUD endpoints:

- Create router with `APIRouter(prefix="/tokens", tags=["tokens"])`
- Implement dependency injection function `async def get_token_service() -> TokenService` following pattern from `src/features/workspaces/routes.py`
- Implement endpoints:
  - `POST /tokens/`: Create new token (status 201)
  - `GET /tokens/`: List all tokens with optional `active_only` query param
  - `GET /tokens/{token_id}`: Get token by ID
  - `PATCH /tokens/{token_id}`: Update token
  - `DELETE /tokens/{token_id}`: Delete token (status 204)
- Use `Depends(get_token_service)` for service injection
- Add proper OpenAPI documentation with `summary` and `description` parameters
- Follow the route pattern from `src/features/workspaces/routes.py` and `src/features/tasks/routes.py`
- Do NOT add try-except blocks - let domain exceptions bubble up to global handler per `CLAUDE.md`

### src/core/notion/client_factory.py(NEW)

References:

- src/core/notion/client.py
- src/config/settings.py
- src/core/database/connection.py
- src/features/workspaces/routes.py (for DB connection pattern)

Create `NotionClientFactory` class for creating Notion clients with token resolution:

- Implement `@staticmethod async def create_client(token_id: Optional[str] = None) -> AsyncClient` method
- Logic:
  - If `token_id` is provided:
    - **CRITICAL**: Get database connection using pattern from `src/features/workspaces/routes.py:21-25`
    - Create TokenRepository with database: `db_connection = DatabaseConnection()` then `repository = TokenRepository(await db_connection.get_database())`
    - Use repository to get token by ID: `token = await repository.get_by_id(token_id)`
    - Raise `NotFoundError` if token not found
    - Raise `ValidationError` if token is inactive (`not token.is_active`)
    - Use token's API key: `api_key = token.token`
  - If `token_id` is None:
    - Fallback to `get_settings().notion_api_key` from environment variable
  - Create and return `AsyncClient` with resolved API key and `notion_version` from settings
- Import `AsyncClient` from `notion_client` library
- Import `get_settings` from `src/config/settings.py`
- Import `TokenRepository` from `src/features/tokens/repository.py`
- Import `DatabaseConnection` from `src/core/database/connection.py`
- Import domain exceptions `NotFoundError`, `ValidationError` from `src/core/errors/exceptions.py`
- Add logging for token resolution (log token name/ID but never raw token value)
- Follow the client creation pattern from `src/core/notion/client.py` but with token resolution logic

### src/features/tasks/services/notion_task_service.py(MODIFY)

References:

- src/core/notion/client.py
- Line 43-58 (current __init__ and _get_client implementation)

**IMPORTANT - PRESERVE DI PATTERN**: Do NOT modify the service layer. The current implementation already supports DI via constructor injection of `notion_client`. Token-based client creation should happen in the routes layer (dependency injection functions).

**NO CHANGES NEEDED TO THIS FILE**. The service already:
- Accepts `notion_client: Optional[AsyncClient] = None` in constructor (line 43)
- Uses injected client if provided, otherwise calls `get_notion_client()` singleton (line 54-58)
- This DI pattern allows routes to inject token-based clients

The token selection logic will be implemented in `src/features/tasks/routes.py` by modifying the `get_task_service()` dependency function to conditionally create clients based on `token_id`.

### src/features/tasks/routes.py(MODIFY)

References:

- src/features/workspaces/routes.py (for dependency pattern)
- src/core/notion/client_factory.py (new factory)

Update task routes to accept optional `token_id` query parameter and inject token-based client:

**Step 1: Modify dependency injection function**
- Update `get_task_service()` function to accept `token_id` parameter:
  ```python
  async def get_task_service(
      token_id: Optional[str] = Query(None, description="Notion API token ID to use for this request")
  ) -> NotionTaskService:
      """Dependency injection for task service with optional token selection."""
      if token_id:
          # Create client with specific token
          from src.core.notion.client_factory import NotionClientFactory
          notion_client = await NotionClientFactory.create_client(token_id)
          return NotionTaskService(notion_client=notion_client)
      # No token specified - use default singleton (env var)
      return NotionTaskService()
  ```

**Step 2: Update route handlers**
- **NO CHANGES TO ROUTE SIGNATURES** - the `token_id` parameter is captured by the dependency function
- All routes continue to use `task_service: Annotated[NotionTaskService, Depends(get_task_service)]`
- The dependency function automatically injects the correct client based on `token_id` query param
- Routes: `create_task`, `list_tasks`, `update_task`, `delete_task` remain unchanged

**Step 3: Import NotionClientFactory**
- Add import at top of file: `from src.core.notion.client_factory import NotionClientFactory`

This approach:
- âœ… Preserves DI pattern - service receives pre-configured client
- âœ… Maintains backward compatibility - no token_id uses env var
- âœ… Clean separation - routes don't know about token resolution logic
- âœ… Testable - can override get_task_service in tests

### src/main.py(MODIFY)

Register the new tokens router:

- Import: `from src.features.tokens.routes import router as tokens_router`
- Add `app.include_router(tokens_router)` after the existing router includes (after line 186)
- Follow the same pattern as existing router includes for tasks, workspaces, and users

### frontend/src/types/token.ts(NEW)

References: 

- frontend/src/types/task.ts
- frontend/src/types/api.ts

Create TypeScript types for token management matching backend DTOs:

- `export interface NotionToken`: Fields matching `TokenResponse` from backend (id, name, token_preview, description, created_at, updated_at, is_active)
- `export interface CreateTokenRequest`: Fields matching backend DTO (name, token, description)
- `export interface UpdateTokenRequest`: Fields matching backend DTO (name, description, is_active)
- `export interface TokenListResponse`: Fields matching backend DTO (tokens, total)
- Follow the type definition pattern from `frontend/src/types/task.ts`
- Add JSDoc comments describing each interface

### frontend/src/api/tokenApi.ts(NEW)

References: 

- frontend/src/api/client.ts

Create token API client with CRUD methods:

- Import types from `../types/token`
- Import `apiClient` from `./client`
- Export `tokenApi` object with methods:
  - `listTokens: async (): Promise<TokenListResponse>` - GET /tokens (**NO /api prefix**)
  - `createToken: async (data: CreateTokenRequest): Promise<NotionToken>` - POST /tokens
  - `getToken: async (id: string): Promise<NotionToken>` - GET /tokens/{id}
  - `updateToken: async (id: string, data: UpdateTokenRequest): Promise<NotionToken>` - PATCH /tokens/{id}
  - `deleteToken: async (id: string): Promise<void>` - DELETE /tokens/{id}
- Use `apiClient.get()`, `apiClient.post()`, `apiClient.patch()`, `apiClient.delete()` methods
- **IMPORTANT**: API paths do NOT include `/api` prefix - backend routers are mounted at root level (e.g., `/tokens`, `/tasks`, `/workspaces`)
- Follow the API client pattern from `frontend/src/api/taskApi.ts` if it exists, or use the pattern from `frontend/src/api/client.ts`
- Add JSDoc comments for each method

### frontend/src/hooks/useTokens.ts(NEW)

References: 

- frontend/src/hooks/useTheme.ts

Create React hook for token management:

- Import `useState` from React
- Import types from `../types/token`
- Import `tokenApi` from `../api/tokenApi`
- Export `useTokens` hook with:
  - State: `tokens` (NotionToken[]), `isLoading` (boolean), `error` (string | null)
  - Methods:
    - `loadTokens: async () => Promise<void>` - Fetch all tokens
    - `createToken: async (data: CreateTokenRequest) => Promise<NotionToken>` - Create and add to list
    - `updateToken: async (id: string, data: UpdateTokenRequest) => Promise<NotionToken>` - Update in list
    - `deleteToken: async (id: string) => Promise<void>` - Remove from list
  - Return object with state and methods
- Handle loading states and errors appropriately
- Follow React hooks best practices

### frontend/src/store/chatStore.ts(MODIFY)

Extend Zustand store to manage selected token:

- Add `selectedTokenId: string | null` to `ChatState` interface
- Add `setSelectedTokenId: (id: string | null) => void` action to interface
- Initialize `selectedTokenId` from localStorage: `localStorage.getItem('selectedTokenId') || null`
- Implement `setSelectedTokenId` action:
  - If `id` is provided, save to localStorage with `localStorage.setItem('selectedTokenId', id)`
  - If `id` is null, remove from localStorage with `localStorage.removeItem('selectedTokenId')`
  - Update state with `set({ selectedTokenId: id })`
- Update `sendCommand` method to include `token_id` in API requests:
  - Get `selectedTokenId` from state in `sendCommand`
  - In `commandToApiRequest` result, append `token_id` to query params for all methods
  - For GET requests: add to `apiRequest.params` object
    ```typescript
    if (selectedTokenId) {
      apiRequest.params = { ...apiRequest.params, token_id: selectedTokenId };
    }
    ```
  - For POST/PATCH/DELETE: append to endpoint URL as query param
    ```typescript
    if (selectedTokenId) {
      const separator = apiRequest.endpoint.includes('?') ? '&' : '?';
      apiRequest.endpoint = `${apiRequest.endpoint}${separator}token_id=${selectedTokenId}`;
    }
    ```
- **NOTE**: All API endpoints use paths without `/api` prefix (e.g., `/tasks`, `/tokens`)
- Follow the existing state management pattern in the file

### frontend/src/components/AuthModal.tsx(MODIFY)

Enhance AuthModal with token management tab:

- Import `Key` icon from `lucide-react`
- Import `useTokens` hook from `../hooks/useTokens`
- Import `useChatStore` to access `selectedTokenId` and `setSelectedTokenId`
- Add state for new token form: `newTokenName`, `newTokenValue`, `newTokenDescription`
- Update `activeTab` type to include 'tokens': `useState<'api' | 'tokens' | 'workspace'>('api')`
- Add new tab to tabs array: `{ id: 'tokens', label: 'Manage Tokens', icon: Key }`
- Call `useTokens()` hook and `loadTokens()` on component mount
- Implement token management tab content (when `activeTab === 'tokens'`):
  - **Add Token Form section**: Input fields for name, token (password type), description, and "Add Token" button
  - **Token List section**: Display all tokens with:
    - Radio button for selection (checked if `token.id === selectedTokenId`)
    - Token name, token_preview, and description
    - "Delete" button for each token
  - Handle `handleCreateToken`: Call `createToken()` from hook, clear form, show success feedback
  - Handle `handleSelectToken`: Call `setSelectedTokenId()` from store
  - Handle `handleDeleteToken`: Call `deleteToken()` from hook, if deleted token was selected, clear selection
- Add loading and error states display
- Follow the existing tab structure and styling from the current AuthModal implementation
- Use existing UI components (Button, Input) and Tailwind CSS classes for consistency

### tests/unit/test_token_service.py(NEW)

References: 

- tests/unit/test_workspace_service.py
- tests/unit/test_tasks_service.py

Create unit tests for TokenService:

- Import pytest, AsyncMock, Mock
- Import TokenService, TokenRepository, NotionToken
- Import domain exceptions (NotFoundError, ValidationError)
- Test cases:
  - `test_create_token_success`: Mock repository.create, verify service creates token and masks response
  - `test_create_token_invalid_format`: Test validation error for token not starting with "secret_"
  - `test_list_tokens_masks_values`: Verify all tokens in list have masked token_preview
  - `test_get_token_not_found`: Verify NotFoundError raised for non-existent token
  - `test_update_token_success`: Mock repository.update, verify service updates and returns masked response
  - `test_delete_token_success`: Mock repository.delete, verify deletion
  - `test_mask_token_function`: Test static mask_token method with various inputs
- Follow the test pattern from `tests/unit/test_workspace_service.py` and `tests/unit/test_tasks_service.py`
- Use AsyncMock for repository methods
- Use pytest fixtures for common setup

### tests/integration/test_token_api.py(NEW)

References: 

- tests/integration/test_workspace_api.py
- tests/integration/test_tasks_api.py
- tests/conftest.py(MODIFY)

Create integration tests for token API endpoints:

- Import pytest, httpx AsyncClient
- Import test fixtures from conftest
- Test cases:
  - `test_create_token`: POST /tokens with valid data, verify 201 response and token_preview masking
  - `test_create_token_invalid_format`: POST /tokens with invalid token format, verify 400 error
  - `test_list_tokens`: GET /tokens, verify response structure and token masking
  - `test_get_token_by_id`: GET /tokens/{id}, verify single token response
  - `test_get_token_not_found`: GET /tokens/{invalid_id}, verify 404 error
  - `test_update_token`: PATCH /tokens/{id}, verify update and response
  - `test_delete_token`: DELETE /tokens/{id}, verify 204 response
  - `test_delete_token_not_found`: DELETE /tokens/{invalid_id}, verify 404 error
- Follow the integration test pattern from `tests/integration/test_workspace_api.py` and `tests/integration/test_tasks_api.py`
- Use the `client` fixture from conftest
- Mock MongoDB operations via conftest fixtures

### tests/integration/test_tasks_with_token.py(NEW)

References: 

- tests/integration/test_tasks_api.py
- tests/conftest.py(MODIFY)

Create integration tests for task operations with token_id parameter:

- Import pytest, httpx AsyncClient
- Import test fixtures from conftest
- Test cases:
  - `test_create_task_with_token_id`: POST /tasks?token_id={id}, verify task creation uses specified token
  - `test_list_tasks_with_token_id`: GET /tasks?token_id={id}, verify listing uses specified token
  - `test_update_task_with_token_id`: PATCH /tasks/{task_id}?token_id={id}, verify update uses specified token
  - `test_delete_task_with_token_id`: DELETE /tasks/{task_id}?token_id={id}, verify deletion uses specified token
  - `test_task_operations_without_token_id`: Verify all operations work without token_id (fallback to env var)
  - `test_task_with_invalid_token_id`: Verify 404 error when token_id doesn't exist
  - `test_task_with_inactive_token`: Verify error when using inactive token
- Mock NotionClientFactory to verify it's called with correct token_id
- Follow the integration test pattern from `tests/integration/test_tasks_api.py`
- Use the `client` fixture from conftest

### tests/conftest.py(MODIFY)

Add test fixtures for token management:

- Create `mock_token_repository` fixture following the pattern of `mock_workspace_service` and `mock_user_repository`:
  - Create AsyncMock with spec=TokenRepository
  - Mock CRUD methods (create, get_by_id, list_all, update, delete, get_token_value)
  - Store tokens in fixture state for retrieval
  - Override `get_token_service` dependency in FastAPI app
  - Clean up overrides after test
- Create `mock_notion_client_factory` fixture:
  - Patch `NotionClientFactory.create_client` to return mock Notion client
  - Verify token_id parameter is passed correctly
  - Return the same mock client from existing `mock_notion_client` fixture
- Follow the existing fixture patterns in the file
- Ensure fixtures are autouse=True where appropriate