# PRD: API Token Management & Enhanced Frontend Integration

## Overview
Implement a comprehensive API token management system that allows users to create, manage, and select Notion API tokens through the frontend UI. The backend will store these tokens securely in MongoDB and use the selected token for all Notion API operations.

## Current State

### Frontend
- Settings modal (`AuthModal`) where users input raw Notion API key and database ID
- API key stored in browser `sessionStorage`
- Commands parsed and sent to backend via API client using `X-API-Key` header
- No token name/identification system
- No token selection UI

### Backend
- Global `NOTION_API_KEY` from environment variables
- FastAPI routes for tasks, workspaces, users
- MongoDB for data persistence
- No per-user token management
- No token CRUD endpoints

## Goals

1. **Backend Token Management**: Create CRUD API for Notion API tokens with MongoDB storage
2. **Frontend Token UI**: Enhance settings to display, create, and select tokens by name
3. **Token-Based Authentication**: Backend uses user-selected token for Notion API requests
4. **Security**: Display token names with last 6 characters only in UI
5. **Backward Compatibility**: Keep environment variable `NOTION_API_KEY` as fallback

## Requirements

### 1. Backend: Token CRUD API

#### 1.1 Data Model (`src/features/tokens/models.py`)

```python
class NotionToken(BaseModel):
    """MongoDB model for Notion API tokens."""
    id: PydanticObjectId = Field(alias="_id")
    name: str = Field(description="Human-readable token name")
    token: str = Field(description="Raw Notion API token (secret_...)")
    description: Optional[str] = Field(None, description="Optional description")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    is_active: bool = Field(default=True, description="Whether token is active")
```

#### 1.2 API Endpoints (`src/features/tokens/routes.py`)

**Base Path**: `/api/tokens`

| Method | Endpoint | Description | Request Body | Response |
|--------|----------|-------------|--------------|----------|
| GET | `/api/tokens` | List all tokens | - | `TokenListResponse` |
| POST | `/api/tokens` | Create new token | `CreateTokenRequest` | `TokenResponse` |
| GET | `/api/tokens/{token_id}` | Get token by ID | - | `TokenResponse` |
| PATCH | `/api/tokens/{token_id}` | Update token | `UpdateTokenRequest` | `TokenResponse` |
| DELETE | `/api/tokens/{token_id}` | Delete token | - | 204 No Content |

#### 1.3 DTOs

**CreateTokenRequest**:
```python
{
    "name": str,           # Required, 1-100 chars
    "token": str,          # Required, starts with "secret_"
    "description": str     # Optional
}
```

**UpdateTokenRequest**:
```python
{
    "name": str,           # Optional
    "description": str,    # Optional
    "is_active": bool      # Optional
}
```

**TokenResponse** (for GET/POST/PATCH):
```python
{
    "id": str,
    "name": str,
    "token_preview": str,   # "******...abc123" (last 6 chars)
    "description": str,
    "created_at": datetime,
    "updated_at": datetime,
    "is_active": bool
}
```

**TokenListResponse**:
```python
{
    "tokens": List[TokenResponse],
    "total": int
}
```

**IMPORTANT**: Never return the full token in API responses (except for internal backend use).

#### 1.4 Repository (`src/features/tokens/repository.py`)

Following the DI pattern from `CLAUDE.md`:

```python
class TokenRepository:
    """Repository for token CRUD operations."""

    async def create(self, token_data: dict) -> NotionToken
    async def get_by_id(self, token_id: str) -> Optional[NotionToken]
    async def list_all(self, active_only: bool = True) -> List[NotionToken]
    async def update(self, token_id: str, updates: dict) -> NotionToken
    async def delete(self, token_id: str) -> None
    async def get_token_value(self, token_id: str) -> str  # Returns raw token
```

#### 1.5 Service (`src/features/tokens/services/token_service.py`)

Following the DI pattern:

```python
class TokenService:
    def __init__(self, repository: Optional[TokenRepository] = None):
        self._repository = repository or TokenRepository()

    async def create_token(self, request: CreateTokenRequest) -> TokenResponse
    async def list_tokens(self) -> TokenListResponse
    async def get_token(self, token_id: str) -> TokenResponse
    async def update_token(self, token_id: str, request: UpdateTokenRequest) -> TokenResponse
    async def delete_token(self, token_id: str) -> None

    @staticmethod
    def mask_token(raw_token: str) -> str:
        """Return masked token showing last 6 chars: '******...abc123'"""
        if len(raw_token) <= 6:
            return "******"
        return f"******...{raw_token[-6:]}"
```

### 2. Backend: Token Selection for Notion API Requests

#### 2.1 Update Task Service

Modify `NotionTaskService` to accept a `token_id` parameter:

```python
class NotionTaskService:
    async def create_task(
        self,
        task_data: CreateTaskRequest,
        token_id: Optional[str] = None
    ) -> CreateTaskResponse:
        """
        Create task using specified token ID or fallback to env var.
        """
        notion_client = await self._get_notion_client(token_id)
        # ... rest of implementation

    async def _get_notion_client(self, token_id: Optional[str] = None):
        """Get Notion client with appropriate token."""
        if token_id:
            token_repo = TokenRepository()
            api_key = await token_repo.get_token_value(token_id)
        else:
            # Fallback to environment variable
            api_key = get_settings().notion_api_key

        return NotionClient(api_key)
```

#### 2.2 Update Task Routes

Add `token_id` as optional query parameter or header:

**Option A: Query Parameter** (Recommended)
```python
@router.post("/")
async def create_task(
    task_data: CreateTaskRequest,
    token_id: Optional[str] = Query(None, description="Notion API token ID to use"),
    task_service: NotionTaskService = Depends(get_task_service)
) -> CreateTaskResponse:
    return await task_service.create_task(task_data, token_id=token_id)
```

**Option B: Custom Header**
```python
@router.post("/")
async def create_task(
    task_data: CreateTaskRequest,
    task_service: NotionTaskService = Depends(get_task_service),
    x_token_id: Optional[str] = Header(None, alias="X-Token-ID")
) -> CreateTaskResponse:
    return await task_service.create_task(task_data, token_id=x_token_id)
```

### 3. Frontend: Enhanced Token Management UI

#### 3.1 New API Client Methods (`frontend/src/api/tokenApi.ts`)

```typescript
export interface NotionToken {
  id: string;
  name: string;
  token_preview: string;  // "******...abc123"
  description?: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
}

export interface CreateTokenRequest {
  name: string;
  token: string;
  description?: string;
}

export interface UpdateTokenRequest {
  name?: string;
  description?: string;
  is_active?: boolean;
}

export const tokenApi = {
  // List all tokens
  listTokens: async (): Promise<{ tokens: NotionToken[]; total: number }> => {
    return apiClient.get('/api/tokens');
  },

  // Create new token
  createToken: async (data: CreateTokenRequest): Promise<NotionToken> => {
    return apiClient.post('/api/tokens', data);
  },

  // Update token
  updateToken: async (id: string, data: UpdateTokenRequest): Promise<NotionToken> => {
    return apiClient.patch(`/api/tokens/${id}`, data);
  },

  // Delete token
  deleteToken: async (id: string): Promise<void> => {
    return apiClient.delete(`/api/tokens/${id}`);
  },
};
```

#### 3.2 Update Chat Store (`frontend/src/store/chatStore.ts`)

Add token selection state:

```typescript
interface ChatState {
  messages: Message[];
  isLoading: boolean;
  databaseId: string | null;
  selectedTokenId: string | null;  // NEW

  setDatabaseId: (id: string) => void;
  setSelectedTokenId: (id: string | null) => void;  // NEW
  addMessage: (message: Omit<Message, 'id'>) => void;
  sendCommand: (text: string) => Promise<void>;
  clearMessages: () => void;
}

export const useChatStore = create<ChatState>((set, get) => ({
  // ... existing state
  selectedTokenId: localStorage.getItem('selectedTokenId') || null,  // NEW

  setSelectedTokenId: (id: string | null) => {  // NEW
    if (id) {
      localStorage.setItem('selectedTokenId', id);
    } else {
      localStorage.removeItem('selectedTokenId');
    }
    set({ selectedTokenId: id });
  },

  sendCommand: async (text: string) => {
    const { addMessage, databaseId, selectedTokenId } = get();  // Include token

    // ... existing validation code

    // Convert to API request
    const apiRequest = commandToApiRequest(parsed, databaseId);

    // Add token_id to request if selected
    if (selectedTokenId && apiRequest.method === 'GET') {
      apiRequest.params = {
        ...apiRequest.params,
        token_id: selectedTokenId
      };
    } else if (selectedTokenId) {
      // For POST/PATCH/DELETE, add to query params
      apiRequest.endpoint += `?token_id=${selectedTokenId}`;
    }

    // ... rest of implementation
  },
}));
```

#### 3.3 Enhanced Settings Modal (`frontend/src/components/AuthModal.tsx`)

Update `AuthModal` to include:

1. **Token Management Tab**: New tab for managing tokens
2. **Token List**: Display all available tokens
3. **Add Token Form**: Form to create new token
4. **Token Selection**: Radio buttons or dropdown to select active token

**New Tab Structure**:
```tsx
const tabs = [
  { id: 'api', label: 'API Configuration', icon: KeyRound },
  { id: 'tokens', label: 'Manage Tokens', icon: Key },  // NEW
  { id: 'workspace', label: 'Workspace Info', icon: Info },
];
```

**Token Management Tab Content**:
```tsx
{activeTab === 'tokens' && (
  <div className="space-y-4">
    {/* Add New Token Form */}
    <div className="rounded-2xl border border-slate-200/70 bg-white/70 p-4">
      <h3 className="text-sm font-medium mb-3">Add New Token</h3>
      <div className="space-y-3">
        <Input
          placeholder="Token Name (e.g., 'Production Token')"
          value={newTokenName}
          onChange={(e) => setNewTokenName(e.target.value)}
        />
        <Input
          type="password"
          placeholder="secret_..."
          value={newTokenValue}
          onChange={(e) => setNewTokenValue(e.target.value)}
        />
        <Input
          placeholder="Description (optional)"
          value={newTokenDescription}
          onChange={(e) => setNewTokenDescription(e.target.value)}
        />
        <Button onClick={handleCreateToken}>Add Token</Button>
      </div>
    </div>

    {/* Token List */}
    <div className="space-y-2">
      <h3 className="text-sm font-medium">Available Tokens</h3>
      {tokens.map((token) => (
        <div
          key={token.id}
          className="flex items-center justify-between rounded-xl border border-slate-200 p-3"
        >
          <div className="flex items-center gap-3">
            <input
              type="radio"
              name="selected-token"
              checked={selectedTokenId === token.id}
              onChange={() => handleSelectToken(token.id)}
            />
            <div>
              <p className="font-medium">{token.name}</p>
              <p className="text-xs text-slate-500">{token.token_preview}</p>
              {token.description && (
                <p className="text-xs text-slate-400">{token.description}</p>
              )}
            </div>
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={() => handleDeleteToken(token.id)}
          >
            Delete
          </Button>
        </div>
      ))}
    </div>
  </div>
)}
```

#### 3.4 Token State Hook (`frontend/src/hooks/useTokens.ts`)

```typescript
export function useTokens() {
  const [tokens, setTokens] = useState<NotionToken[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadTokens = async () => {
    setIsLoading(true);
    try {
      const response = await tokenApi.listTokens();
      setTokens(response.tokens);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const createToken = async (data: CreateTokenRequest) => {
    const newToken = await tokenApi.createToken(data);
    setTokens([...tokens, newToken]);
    return newToken;
  };

  const deleteToken = async (id: string) => {
    await tokenApi.deleteToken(id);
    setTokens(tokens.filter(t => t.id !== id));
  };

  return {
    tokens,
    isLoading,
    error,
    loadTokens,
    createToken,
    deleteToken,
  };
}
```

### 4. Backend: Notion Client Factory

Create a centralized Notion client factory that handles token resolution:

**File**: `src/core/notion/client_factory.py`

```python
from typing import Optional
from src.config.settings import get_settings
from src.features.tokens.repository import TokenRepository

class NotionClientFactory:
    """Factory for creating Notion clients with appropriate tokens."""

    @staticmethod
    async def create_client(token_id: Optional[str] = None):
        """
        Create Notion client with specified token or fallback.

        Args:
            token_id: Optional token ID from database

        Returns:
            Notion client instance
        """
        if token_id:
            # Get token from database
            token_repo = TokenRepository()
            token = await token_repo.get_by_id(token_id)

            if not token:
                raise ValueError(f"Token with ID {token_id} not found")

            if not token.is_active:
                raise ValueError(f"Token {token.name} is inactive")

            api_key = token.token
        else:
            # Fallback to environment variable
            api_key = get_settings().notion_api_key

        return NotionClient(api_key)
```

## Implementation Plan

### Phase 1: Backend Foundation (Day 1-2)
1. Create token data model and MongoDB schema
2. Implement token repository with CRUD operations
3. Implement token service with business logic
4. Add token masking utility
5. Write unit tests for repository and service

### Phase 2: Backend API (Day 2-3)
1. Create token CRUD endpoints
2. Add token validation and error handling
3. Update global error handler for token-specific errors
4. Write integration tests for API endpoints
5. Update API documentation

### Phase 3: Backend Integration (Day 3-4)
1. Create NotionClientFactory
2. Update NotionTaskService to use token_id
3. Update all task routes to accept token_id parameter
4. Add migration script to import existing env var token
5. Write tests for token-based operations

### Phase 4: Frontend API Client (Day 4-5)
1. Create tokenApi.ts with CRUD methods
2. Create TypeScript types for token models
3. Add token state to chatStore
4. Update apiMapper to include token_id in requests
5. Write unit tests for token API client

### Phase 5: Frontend UI (Day 5-7)
1. Add "Manage Tokens" tab to AuthModal
2. Create token list component
3. Create add token form
4. Add token selection UI (radio buttons)
5. Implement token CRUD operations in UI
6. Add loading and error states
7. Write UI component tests

### Phase 6: Testing & Documentation (Day 7-8)
1. End-to-end testing of token flow
2. Test fallback to environment variable
3. Test error scenarios (invalid token, inactive token)
4. Update README with token management guide
5. Create user documentation
6. Performance testing

## Security Considerations

1. **Token Storage**: Raw tokens stored in MongoDB with appropriate access controls
2. **Token Display**: Never display full token in UI, only masked version
3. **Token Transmission**: Use HTTPS for all API requests
4. **Token Deletion**: Soft delete or archive instead of hard delete
5. **Token Validation**: Validate token format (starts with "secret_")
6. **Audit Logging**: Log token creation, updates, and usage

## Backward Compatibility

1. Keep `NOTION_API_KEY` environment variable as fallback
2. If no token_id is provided in request, use env var token
3. Existing deployments continue to work without changes
4. Frontend gracefully handles absence of tokens (falls back to env var)

## Success Metrics

1. Users can create and manage multiple Notion API tokens
2. Users can select which token to use for operations
3. Token preview displays correctly (last 6 chars)
4. Backend successfully uses selected token for Notion API calls
5. Fallback to environment variable works when no token selected
6. No regression in existing functionality

## Edge Cases & Error Handling

1. **No tokens available**: Show empty state with "Add Token" CTA
2. **Invalid token format**: Validate on frontend and backend
3. **Inactive token selected**: Show error, prompt to select active token
4. **Token deleted while selected**: Clear selection, fallback to env var
5. **Notion API rejects token**: Show clear error message with token name
6. **Database unavailable**: Fallback to environment variable token

## Future Enhancements

1. Token expiration dates and renewal reminders
2. Token usage analytics and rate limiting
3. Per-workspace token assignment
4. OAuth integration for token generation
5. Token rotation policies
6. Role-based access control for token management

## Questions & Decisions

| Question | Decision |
|----------|----------|
| Token scope | Shared tokens across all users |
| Token selection | User selects in UI, sends token_id to backend |
| Environment variable | Keep as fallback |
| Token display | Show last 6 characters |
| Token parameter | Query parameter `token_id` (recommended) |

## API Examples

### Create Token
```bash
POST /api/tokens
Content-Type: application/json

{
  "name": "Production Token",
  "token": "secret_abc123xyz789...",
  "description": "Main production Notion workspace"
}

# Response
{
  "id": "507f1f77bcf86cd799439011",
  "name": "Production Token",
  "token_preview": "******...xyz789",
  "description": "Main production Notion workspace",
  "created_at": "2025-01-15T10:30:00Z",
  "updated_at": "2025-01-15T10:30:00Z",
  "is_active": true
}
```

### List Tokens
```bash
GET /api/tokens

# Response
{
  "tokens": [
    {
      "id": "507f1f77bcf86cd799439011",
      "name": "Production Token",
      "token_preview": "******...xyz789",
      "is_active": true
    },
    {
      "id": "507f1f77bcf86cd799439012",
      "name": "Development Token",
      "token_preview": "******...abc123",
      "is_active": true
    }
  ],
  "total": 2
}
```

### Create Task with Token
```bash
POST /tasks?token_id=507f1f77bcf86cd799439011
Content-Type: application/json

{
  "title": "New Task",
  "notion_database_id": "1a2b3c4d...",
  "priority": "High"
}
```

## File Structure

```
src/features/tokens/
├── __init__.py
├── models.py                          # NotionToken model
├── repository.py                      # TokenRepository
├── routes.py                          # API endpoints
├── services/
│   └── token_service.py              # TokenService
└── dto/
    ├── create_token_request.py
    ├── update_token_request.py
    ├── token_response.py
    └── token_list_response.py

src/core/notion/
└── client_factory.py                 # NotionClientFactory

frontend/src/
├── api/
│   └── tokenApi.ts                   # Token API client
├── hooks/
│   └── useTokens.ts                  # Token management hook
├── types/
│   └── token.ts                      # Token TypeScript types
└── components/
    └── AuthModal.tsx                 # Enhanced with token management
```
